\documentclass[12pt]{article}

\usepackage{amsmath}

\input{../../tex/preamble.tex}

\begin{document}
\makemytitlepage{3}{Сортировка чисел на GPU. Свертка, сканирование, гистограмма.}

\se{Цель работы}

Ознакомление с фундаментальными алгоритмами GPU: свертка
(reduce), сканирование (blelloch scan) и гистограмма (histogram). Реализация одной из
сортировок на CUDA. Использование разделяемой и других видов памяти.
Исследование производительности программы с помощью утилиты nvprof
(обязательно отразить в отчете).

\textbf{Вариант 5.} Сортировка чет-нечет.

\textbf{Входные данные.}
В первых четырех байтах записывается целое число n --
длина массива чисел, далее следуют n чисел типа заданного вариантом.

\textbf{Выходные данные.}

В бинарном виде записывают n отсортированных по
возрастанию чисел.


Требуется реализовать блочную сортировку чет-нечет для чисел типа int.
Должны быть реализованы:

\begin{itemize}
	\item Алгоритм чет-нечет сортировки для предварительной сортировки
	      блоков.
	\item Алгоритм битонического слияния, с использованием разделяемой
	      памяти.
\end{itemize}

Ограничения: $n <= 16 * 10^6$

\nvidia

\se{Метод решения}

Очень долго не понимал как соединить 2 сортировки, пока не осознал битоническое слияние.

Массив делится на блоки фиксированного размера, на каждом блоке отрабатывает сортировка чёт-нечёт.
Этот трюк даёт $n$ неубывающих последовательностей.

Сначала я хотел сделать битоническое слияние для двух таких получившихся последовательностей,
но упёрся в то что на последней итерации надо будет запускать битонику для всего массива.

Тогда другой вариант показался более привлекательным - сливать половинки блоков.
То есть вторую половину от предыдущего блока и первую от последующего.
После этого будет $n-1$ отсортированных блоков, а так же половинка блока в начале массива и половинка в конце.
Вторая итерация так же берёт половинки блоков, но начинается с начала массива, а не с серидины первого блока.

Так, если предположить худший вариант - блок с самыми малыми значениями последний, а с самыми большими первый,
то за $n$ итераций первый блок дойдёт до своего места, как и последний.
Блок будет двигаться по массиву как гусеница, за каждую итерацию одна его половинка будет двигаться на своё место.
Если какие-то элементы оказались разбросаны по массиву, то они встанут на своё место при проходе блока по массиву.

{
\listsource{../src}{main.cu}
}

\newpage

\se{Результаты}

\begin{table}[!htb]
\begin{minipage}{.49\linewidth}
\centering
\caption*{CPU}
\begin{tabular}{|l|r|}
	\hline
	n       & time         \\
	\hline

	10      & 0.623824     \\
	8123    & 9.101413     \\
	10000   & 13.736742    \\
	100000  & 774.255989   \\
	100500  & 789.445012   \\
	1000000 & 70896.706258 \\
	\hline
\end{tabular}
\end {minipage} %
\begin{minipage}{.49\linewidth}
\centering
\caption*{GPU}
\begin{tabular}{|l|r|}
	\hline
	n       & time        \\
	\hline

	10      & 269.320362  \\
	8123    & 247.722819  \\
	10000   & 178.349589  \\
	100000  & 193.055952  \\
	100500  & 204.694692  \\
	1000000 & 1527.011376 \\
	\hline
\end{tabular}
\end {minipage}
\end{table}

\se{Профилирование}

\se{Выводы}


\end{document}