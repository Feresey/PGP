\documentclass[12pt]{article}

\usepackage{amsmath}

\input{../../tex/preamble.tex}

\begin{document}
\makemytitlepage{2}{Обработка изображений на GPU. Фильтры.}

\se{Цель работы}

Научиться использовать GPU для обработки изображений.
Использование текстурной памяти.

\textbf{Вариант 6.} Выделение контуров. Метод Превитта(Прюитта).

\textbf{Входные данные.} На первой строке задается путь к исходному изображению,
на второй, путь к конечному изображению. $w*h <= 10$

\nvidia

\se{Метод решения}

Метод Превитта основан на обработке всех пикселей изображения двумя ядрами 3x3,
которые сворачивают изображение, вычисляя приблизительные производные:
одну по горизонтали, другую по вертикали.

\[
	G_x = \begin{bmatrix}
		-1 & -1 & -1 \\
		0  & 0  & 0  \\
		1  & 1  & 1
	\end{bmatrix},
	G_y = \begin{bmatrix}
		-1 & 0 & 1 \\
		-1 & 0 & 1 \\
		-1 & 0 & 1
	\end{bmatrix}
\]

Чтобы получить значение градиента в точке достаточно взять среднеквадратичное значение градиентов по $x$ и $y$.

\[
	G=\sqrt{G_x^2+G_y^2}
\]

\se{Описание программы}
Единственный файл \lstinline|main.cu|.

По условиям лабораторной используется текстурная ссылка для хранения пикселей.
Единственное ядро использует двумерную сетку потоков и обрабатывает отдельные пиксели.
Значение градиента записывается в результирующий массив типа \lstinline|uchar4|.

\listsource{../src}{main.cu}

\newpage

\se{Результаты}

\begin{table*}[!htb]
	\begin{subtable}{.333\linewidth}
		\caption{$10^3$ элементов}
		\centering

		\lstinline|cpu time = 0.007000|

		\begin{tabular}{|c|c|c|}
			\hline
			blocks & threads & time       \\
			\hline

			128    & 128     & 000.036640 \\
			128    & 32      & 000.037088 \\
			32     & 128     & 000.039008 \\
			32     & 32      & 000.041248 \\
			32     & 1024    & 000.041920 \\
			1024   & 128     & 000.043584 \\
			1      & 32      & 000.046112 \\
			128    & 1024    & 000.047040 \\
			128    & 1       & 000.047520 \\
			1024   & 1       & 000.050208 \\
			32     & 1       & 000.054240 \\
			1024   & 32      & 000.057536 \\
			1      & 1024    & 000.066880 \\
			1      & 128     & 000.076160 \\
			1      & 1       & 000.149152 \\
			1024   & 1024    & 000.163264 \\
			\hline
		\end{tabular}
	\end{subtable}
	\begin{subtable}{.333\linewidth}
		\caption{$10^5$ элементов}
		\centering

		\lstinline|cpu time = 0.200000|

		\begin{tabular}{|c|c|c|}
			\hline
			blocks & threads & time       \\
			\hline

			128    & 128     & 000.037600 \\
			32     & 1024    & 000.040832 \\
			32     & 128     & 000.042400 \\
			1024   & 128     & 000.046528 \\
			128    & 1024    & 000.055168 \\
			1      & 1024    & 000.067008 \\
			128    & 32      & 000.091232 \\
			1024   & 32      & 000.093760 \\
			32     & 32      & 000.117824 \\
			1024   & 1024    & 000.170272 \\
			1      & 128     & 000.444320 \\
			1      & 32      & 001.752160 \\
			1024   & 1       & 001.756608 \\
			128    & 1       & 001.949856 \\
			32     & 1       & 003.432608 \\
			1      & 1       & 011.677664 \\
			\hline
		\end{tabular}
	\end{subtable}
	\begin{subtable}{.333\linewidth}
		\caption{$10^6$ элементов}
		\centering

		\lstinline|cpu time = 1.997000|

		\begin{tabular}{|c|c|c|}
			\hline
			blocks & threads & time       \\
			\hline

			1024   & 128     & 000.273600 \\
			32     & 1024    & 000.277280 \\
			128    & 1024    & 000.290944 \\
			128    & 128     & 000.293120 \\
			32     & 128     & 000.345056 \\
			1024   & 1024    & 000.441344 \\
			1      & 1024    & 000.578688 \\
			1024   & 32      & 000.763008 \\
			128    & 32      & 000.833280 \\
			32     & 32      & 001.102944 \\
			1      & 128     & 004.359520 \\
			1      & 32      & 017.438175 \\
			1024   & 1       & 017.528929 \\
			128    & 1       & 025.771551 \\
			32     & 1       & 034.263199 \\
			1      & 1       & 116.714722 \\
			\hline
		\end{tabular}
	\end{subtable}

\end{table*}

\se{Выводы}

Всю жизнь я делал реверс вектора в один поток и мне даже не приходила в голову идея
этот алгоритм распараллелить. Как оказалось, это имееет смысл для GPU.

Иногда нужно производить быстрый реверс вектора, например для подготовки данных для
обучения нейросети.

Судя по результатам тестов не всегда имееет смысл отдавать все доступные ресурсы на
выполнение операции. В тесте с небольшим количеством элементов ($10^3$)
вариант с \lstinline|<<<1024,1024>>>| показал худший результат из всех. Больше времени ушло на создание потоков,
чем на выполнение кода.

В итоге, GPU оказалась быстрее чем CPU примерно в 7 раз (на самом большом тесте).
Из этого можно сделать вывод, что использование GPU не целесообразно для мизерного набора данных.

\end{document}